\generated\src\Generated\AudioTranslationServiceClient.cs:
```
// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Threading;

namespace TranlsationService
{
    /// <summary></summary>
    public partial class AudioTranslationServiceClient
    {
        private readonly Uri _endpoint;
        private Routes _cachedRoutes;

        /// <summary> Initializes a new instance of AudioTranslationServiceClient for mocking. </summary>
        protected AudioTranslationServiceClient()
        {
        }

        /// <summary> Initializes a new instance of AudioTranslationServiceClient. </summary>
        /// <param name="endpoint"> Service endpoint. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> is null. </exception>
        public AudioTranslationServiceClient(Uri endpoint) : this(endpoint, new AudioTranslationServiceClientOptions())
        {
        }

        /// <summary> Initializes a new instance of AudioTranslationServiceClient. </summary>
        /// <param name="endpoint"> Service endpoint. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> is null. </exception>
        public AudioTranslationServiceClient(Uri endpoint, AudioTranslationServiceClientOptions options)
        {
            Argument.AssertNotNull(endpoint, nameof(endpoint));

            options ??= new AudioTranslationServiceClientOptions();

            _endpoint = endpoint;
            Pipeline = ClientPipeline.Create(options, Array.Empty<PipelinePolicy>(), Array.Empty<PipelinePolicy>(), Array.Empty<PipelinePolicy>());
        }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public ClientPipeline Pipeline { get; }

        /// <summary> Initializes a new instance of Routes. </summary>
        public virtual Routes GetRoutesClient()
        {
            return Volatile.Read(ref _cachedRoutes) ?? Interlocked.CompareExchange(ref _cachedRoutes, new Routes(Pipeline, _endpoint), null) ?? _cachedRoutes;
        }
    }
}

```

\generated\src\Generated\AudioTranslationServiceClient.RestClient.cs:
```
// <auto-generated/>

#nullable disable

namespace TranlsationService
{
    /// <summary></summary>
    public partial class AudioTranslationServiceClient
    {
    }
}

```

\generated\src\Generated\AudioTranslationServiceClientOptions.cs:
```
// <auto-generated/>

#nullable disable

using System.ClientModel.Primitives;

namespace TranlsationService
{
    /// <summary> Client options for <see cref="AudioTranslationServiceClient"/>. </summary>
    public partial class AudioTranslationServiceClientOptions : ClientPipelineOptions
    {
    }
}

```

\generated\src\Generated\Routes.cs:
```
// <auto-generated/>

#nullable disable

using System;
using System.ClientModel;
using System.ClientModel.Primitives;
using System.Threading;
using System.Threading.Tasks;
using TranlsationService.Models;

namespace TranlsationService
{
    /// <summary></summary>
    public partial class Routes
    {
        private readonly Uri _endpoint;

        /// <summary> Initializes a new instance of Routes for mocking. </summary>
        protected Routes()
        {
        }

        internal Routes(ClientPipeline pipeline, Uri endpoint)
        {
            _endpoint = endpoint;
            Pipeline = pipeline;
        }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public ClientPipeline Pipeline { get; }

        /// <summary>
        /// [Protocol Method] processPayment
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual ClientResult ProcessPayment(BinaryContent content, RequestOptions options = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using PipelineMessage message = CreateProcessPaymentRequest(content, options);
            return ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));
        }

        /// <summary>
        /// [Protocol Method] processPayment
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<ClientResult> ProcessPaymentAsync(BinaryContent content, RequestOptions options = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using PipelineMessage message = CreateProcessPaymentRequest(content, options);
            return ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
        }

        /// <summary> processPayment. </summary>
        /// <param name="payment"></param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="payment"/> is null. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        public virtual ClientResult<PaymentResponse> ProcessPayment(Payment payment, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(payment, nameof(payment));

            ClientResult result = ProcessPayment(payment, cancellationToken.CanBeCanceled ? new RequestOptions { CancellationToken = cancellationToken } : null);
            return ClientResult.FromValue((PaymentResponse)result, result.GetRawResponse());
        }

        /// <summary> processPayment. </summary>
        /// <param name="payment"></param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="payment"/> is null. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        public virtual async Task<ClientResult<PaymentResponse>> ProcessPaymentAsync(Payment payment, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(payment, nameof(payment));

            ClientResult result = await ProcessPaymentAsync(payment, cancellationToken.CanBeCanceled ? new RequestOptions { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            return ClientResult.FromValue((PaymentResponse)result, result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] uploadAudio
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> The contentType to use which has the multipart/form-data boundary. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual ClientResult UploadAudio(BinaryContent content, string contentType, RequestOptions options = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using PipelineMessage message = CreateUploadAudioRequest(content, contentType, options);
            return ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));
        }

        /// <summary>
        /// [Protocol Method] uploadAudio
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> The contentType to use which has the multipart/form-data boundary. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<ClientResult> UploadAudioAsync(BinaryContent content, string contentType, RequestOptions options = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using PipelineMessage message = CreateUploadAudioRequest(content, contentType, options);
            return ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
        }

        /// <summary>
        /// [Protocol Method] downloadArtifact
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="ContainerName"></param>
        /// <param name="uploadId"></param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="ContainerName"/> or <paramref name="uploadId"/> is null. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual ClientResult DownloadArtifact(string containerName, string uploadId, RequestOptions options)
        {
            Argument.AssertNotNull(containerName, nameof(containerName));
            Argument.AssertNotNull(uploadId, nameof(uploadId));

            using PipelineMessage message = CreateDownloadArtifactRequest(containerName, uploadId, options);
            return ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));
        }

        /// <summary>
        /// [Protocol Method] downloadArtifact
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="ContainerName"></param>
        /// <param name="uploadId"></param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="ContainerName"/> or <paramref name="uploadId"/> is null. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<ClientResult> DownloadArtifactAsync(string containerName, string uploadId, RequestOptions options)
        {
            Argument.AssertNotNull(containerName, nameof(containerName));
            Argument.AssertNotNull(uploadId, nameof(uploadId));

            using PipelineMessage message = CreateDownloadArtifactRequest(containerName, uploadId, options);
            return ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
        }

        /// <summary> downloadArtifact. </summary>
        /// <param name="ContainerName"></param>
        /// <param name="uploadId"></param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="ContainerName"/> or <paramref name="uploadId"/> is null. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        public virtual ClientResult<BinaryData> DownloadArtifact(string containerName, string uploadId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(containerName, nameof(containerName));
            Argument.AssertNotNull(uploadId, nameof(uploadId));

            ClientResult result = DownloadArtifact(containerName, uploadId, cancellationToken.CanBeCanceled ? new RequestOptions { CancellationToken = cancellationToken } : null);
            return ClientResult.FromValue(result.GetRawResponse().Content, result.GetRawResponse());
        }

        /// <summary> downloadArtifact. </summary>
        /// <param name="ContainerName"></param>
        /// <param name="uploadId"></param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="ContainerName"/> or <paramref name="uploadId"/> is null. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        public virtual async Task<ClientResult<BinaryData>> DownloadArtifactAsync(string containerName, string uploadId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(containerName, nameof(containerName));
            Argument.AssertNotNull(uploadId, nameof(uploadId));

            ClientResult result = await DownloadArtifactAsync(containerName, uploadId, cancellationToken.CanBeCanceled ? new RequestOptions { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            return ClientResult.FromValue(result.GetRawResponse().Content, result.GetRawResponse());
        }
    }
}

```

\generated\src\Generated\Routes.RestClient.cs:
```
// <auto-generated/>

#nullable disable

using System.ClientModel;
using System.ClientModel.Primitives;

namespace TranlsationService
{
    /// <summary></summary>
    public partial class Routes
    {
        private static PipelineMessageClassifier _pipelineMessageClassifier200;

        private static PipelineMessageClassifier PipelineMessageClassifier200 => _pipelineMessageClassifier200 = PipelineMessageClassifier.Create(stackalloc ushort[] { 200 });

        internal PipelineMessage CreateProcessPaymentRequest(BinaryContent content, RequestOptions options)
        {
            PipelineMessage message = Pipeline.CreateMessage();
            message.ResponseClassifier = PipelineMessageClassifier200;
            PipelineRequest request = message.Request;
            request.Method = "POST";
            ClientUriBuilder uri = new ClientUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/payment", false);
            request.Uri = uri.ToUri();
            request.Headers.Set("Content-Type", "application/json");
            request.Headers.Set("Accept", "application/json");
            request.Content = content;
            message.Apply(options);
            return message;
        }

        internal PipelineMessage CreateUploadAudioRequest(BinaryContent content, string contentType, RequestOptions options)
        {
            PipelineMessage message = Pipeline.CreateMessage();
            message.ResponseClassifier = PipelineMessageClassifier200;
            PipelineRequest request = message.Request;
            request.Method = "POST";
            ClientUriBuilder uri = new ClientUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/upload", false);
            request.Uri = uri.ToUri();
            request.Headers.Set("Content-Type", contentType);
            request.Headers.Set("Accept", "application/json");
            request.Content = content;
            message.Apply(options);
            return message;
        }

        internal PipelineMessage CreateDownloadArtifactRequest(string containerName, string uploadId, RequestOptions options)
        {
            PipelineMessage message = Pipeline.CreateMessage();
            message.ResponseClassifier = PipelineMessageClassifier200;
            PipelineRequest request = message.Request;
            request.Method = "GET";
            ClientUriBuilder uri = new ClientUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/download", false);
            uri.AppendQuery("ContainerName", containerName, true);
            uri.AppendQuery("uploadId", uploadId, true);
            request.Uri = uri.ToUri();
            request.Headers.Set("Accept", "application/json");
            message.Apply(options);
            return message;
        }
    }
}

```

\generated\src\Generated\TranlsationServiceModelFactory.cs:
```
// <auto-generated/>

#nullable disable

using System;

namespace TranlsationService.Models
{
    /// <summary> A factory class for creating instances of the models for mocking. </summary>
    public static partial class TranlsationServiceModelFactory
    {
        /// <summary> The Payment. </summary>
        /// <param name="userEmail"></param>
        /// <param name="amount"></param>
        /// <param name="service"></param>
        /// <param name="userId"></param>
        /// <param name="synthesizedAudio"></param>
        /// <returns> A new <see cref="Models.Payment"/> instance for mocking. </returns>
        public static Payment Payment(string userEmail = default, float amount = default, string service = default, string userId = default, bool synthesizedAudio = default)
        {

            return new Payment(
                userEmail,
                amount,
                service,
                userId,
                synthesizedAudio,
                additionalBinaryDataProperties: null);
        }

        /// <summary> The PaymentResponse. </summary>
        /// <param name="message"></param>
        /// <param name="userId"></param>
        /// <returns> A new <see cref="Models.PaymentResponse"/> instance for mocking. </returns>
        public static PaymentResponse PaymentResponse(string message = default, string userId = default)
        {

            return new PaymentResponse(message, userId, additionalBinaryDataProperties: null);
        }
    }
}

```

\generated\src\Generated\Internal\Argument.cs:
```
// <auto-generated/>

#nullable disable

using System;
using System.Collections;
using System.Collections.Generic;

namespace TranlsationService
{
    internal static partial class Argument
    {
        public static void AssertNotNull<T>(T value, string name)
        {
            if (value is null)
            {
                throw new ArgumentNullException(name);
            }
        }

        public static void AssertNotNull<T>(T? value, string name)
            where T : struct 
        {
            if (!value.HasValue)
            {
                throw new ArgumentNullException(name);
            }
        }

        public static void AssertNotNullOrEmpty<T>(IEnumerable<T> value, string name)
        {
            if (value is null)
            {
                throw new ArgumentNullException(name);
            }
            if (value is ICollection<T> collectionOfT && collectionOfT.Count == 0)
            {
                throw new ArgumentException("Value cannot be an empty collection.", name);
            }
            if (value is ICollection collection && collection.Count == 0)
            {
                throw new ArgumentException("Value cannot be an empty collection.", name);
            }
            using IEnumerator<T> e = value.GetEnumerator();
            if (!e.MoveNext())
            {
                throw new ArgumentException("Value cannot be an empty collection.", name);
            }
        }

        public static void AssertNotNullOrEmpty(string value, string name)
        {
            if (value is null)
            {
                throw new ArgumentNullException(name);
            }
            if (value.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", name);
            }
        }

        public static void AssertNotNullOrWhiteSpace(string value, string name)
        {
            if (value is null)
            {
                throw new ArgumentNullException(name);
            }
            if (string.IsNullOrWhiteSpace(value))
            {
                throw new ArgumentException("Value cannot be empty or contain only white-space characters.", name);
            }
        }

        public static void AssertNotDefault<T>(ref T value, string name)
            where T : struct, IEquatable<T> 
        {
            if (value.Equals(default))
            {
                throw new ArgumentException("Value cannot be empty.", name);
            }
        }

        public static void AssertInRange<T>(T value, T minimum, T maximum, string name)
            where T : notnull, IComparable<T> 
        {
            if (minimum.CompareTo(value) > 0)
            {
                throw new ArgumentOutOfRangeException(name, "Value is less than the minimum allowed.");
            }
            if (maximum.CompareTo(value) < 0)
            {
                throw new ArgumentOutOfRangeException(name, "Value is greater than the maximum allowed.");
            }
        }

        public static void AssertEnumDefined(Type enumType, object value, string name)
        {
            if (!Enum.IsDefined(enumType, value))
            {
                throw new ArgumentException($"Value not defined for {enumType.FullName}.", name);
            }
        }

        public static T CheckNotNull<T>(T value, string name)
            where T : class 
        {
            AssertNotNull(value, name);
            return value;
        }

        public static string CheckNotNullOrEmpty(string value, string name)
        {
            AssertNotNullOrEmpty(value, name);
            return value;
        }

        public static void AssertNull<T>(T value, string name, string message = null)
        {
            if (value != null)
            {
                throw new ArgumentException(message ?? "Value must be null.", name);
            }
        }
    }
}

```

\generated\src\Generated\Internal\ChangeTrackingDictionary.cs:
```
// <auto-generated/>

#nullable disable

using System;
using System.Collections;
using System.Collections.Generic;

namespace TranlsationService
{
    internal partial class ChangeTrackingDictionary<TKey, TValue> : IDictionary<TKey, TValue>, IReadOnlyDictionary<TKey, TValue>
        where TKey : notnull
    {
        private IDictionary<TKey, TValue> _innerDictionary;

        public ChangeTrackingDictionary()
        {
        }

        public ChangeTrackingDictionary(IDictionary<TKey, TValue> dictionary)
        {
            if (dictionary == null)
            {
                return;
            }
            _innerDictionary = new Dictionary<TKey, TValue>(dictionary);
        }

        public ChangeTrackingDictionary(IReadOnlyDictionary<TKey, TValue> dictionary)
        {
            if (dictionary == null)
            {
                return;
            }
            _innerDictionary = new Dictionary<TKey, TValue>();
            foreach (var pair in dictionary)
            {
                _innerDictionary.Add(pair);
            }
        }

        public bool IsUndefined => _innerDictionary == null;

        public int Count => IsUndefined ? 0 : EnsureDictionary().Count;

        public bool IsReadOnly => IsUndefined ? false : EnsureDictionary().IsReadOnly;

        public ICollection<TKey> Keys => IsUndefined ? Array.Empty<TKey>() : EnsureDictionary().Keys;

        public ICollection<TValue> Values => IsUndefined ? Array.Empty<TValue>() : EnsureDictionary().Values;

        public TValue this[TKey key]
        {
            get
            {
                if (IsUndefined)
                {
                    throw new KeyNotFoundException(nameof(key));
                }
                return EnsureDictionary()[key];
            }
            set
            {
                EnsureDictionary()[key] = value;
            }
        }

        IEnumerable<TKey> IReadOnlyDictionary<TKey, TValue>.Keys => Keys;

        IEnumerable<TValue> IReadOnlyDictionary<TKey, TValue>.Values => Values;

        public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
        {
            if (IsUndefined)
            {
                IEnumerator<KeyValuePair<TKey, TValue>> enumerateEmpty()
                {
                    yield break;
                }
                return enumerateEmpty();
            }
            return EnsureDictionary().GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        public void Add(KeyValuePair<TKey, TValue> item)
        {
            EnsureDictionary().Add(item);
        }

        public void Clear()
        {
            EnsureDictionary().Clear();
        }

        public bool Contains(KeyValuePair<TKey, TValue> item)
        {
            if (IsUndefined)
            {
                return false;
            }
            return EnsureDictionary().Contains(item);
        }

        public void CopyTo(KeyValuePair<TKey, TValue>[] array, int index)
        {
            if (IsUndefined)
            {
                return;
            }
            EnsureDictionary().CopyTo(array, index);
        }

        public bool Remove(KeyValuePair<TKey, TValue> item)
        {
            if (IsUndefined)
            {
                return false;
            }
            return EnsureDictionary().Remove(item);
        }

        public void Add(TKey key, TValue value)
        {
            EnsureDictionary().Add(key, value);
        }

        public bool ContainsKey(TKey key)
        {
            if (IsUndefined)
            {
                return false;
            }
            return EnsureDictionary().ContainsKey(key);
        }

        public bool Remove(TKey key)
        {
            if (IsUndefined)
            {
                return false;
            }
            return EnsureDictionary().Remove(key);
        }

        public bool TryGetValue(TKey key, out TValue value)
        {
            if (IsUndefined)
            {
                value = default;
                return false;
            }
            return EnsureDictionary().TryGetValue(key, out value);
        }

        public IDictionary<TKey, TValue> EnsureDictionary()
        {
            return _innerDictionary ??= new Dictionary<TKey, TValue>();
        }
    }
}

```

\generated\src\Generated\Internal\ClientPipelineExtensions.cs:
```
// <auto-generated/>

#nullable disable

using System.ClientModel;
using System.ClientModel.Primitives;
using System.Threading.Tasks;

namespace TranlsationService
{
    internal static partial class ClientPipelineExtensions
    {
        public static async ValueTask<PipelineResponse> ProcessMessageAsync(this ClientPipeline pipeline, PipelineMessage message, RequestOptions options)
        {
            await pipeline.SendAsync(message).ConfigureAwait(false);

            if (message.Response.IsError && (options?.ErrorOptions & ClientErrorBehaviors.NoThrow) != ClientErrorBehaviors.NoThrow)
            {
                throw await ClientResultException.CreateAsync(message.Response).ConfigureAwait(false);
            }

            PipelineResponse response = message.BufferResponse ? message.Response : message.ExtractResponse();
            return response;
        }

        public static PipelineResponse ProcessMessage(this ClientPipeline pipeline, PipelineMessage message, RequestOptions options)
        {
            pipeline.Send(message);

            if (message.Response.IsError && (options?.ErrorOptions & ClientErrorBehaviors.NoThrow) != ClientErrorBehaviors.NoThrow)
            {
                throw new ClientResultException(message.Response);
            }

            PipelineResponse response = message.BufferResponse ? message.Response : message.ExtractResponse();
            return response;
        }

        public static async ValueTask<ClientResult<bool>> ProcessHeadAsBoolMessageAsync(this ClientPipeline pipeline, PipelineMessage message, RequestOptions options)
        {
            PipelineResponse response = await pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false);
            switch (response.Status)
            {
                case >= 200 and < 300:
                    return ClientResult.FromValue(true, response);
                case >= 400 and < 500:
                    return ClientResult.FromValue(false, response);
                default:
                    return new ErrorResult<bool>(response, new ClientResultException(response));
            }
        }

        public static ClientResult<bool> ProcessHeadAsBoolMessage(this ClientPipeline pipeline, PipelineMessage message, RequestOptions options)
        {
            PipelineResponse response = pipeline.ProcessMessage(message, options);
            switch (response.Status)
            {
                case >= 200 and < 300:
                    return ClientResult.FromValue(true, response);
                case >= 400 and < 500:
                    return ClientResult.FromValue(false, response);
                default:
                    return new ErrorResult<bool>(response, new ClientResultException(response));
            }
        }
    }
}

```

\generated\src\Generated\Internal\ClientUriBuilder.cs:
```
// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace TranlsationService
{
    internal partial class ClientUriBuilder
    {
        private UriBuilder _uriBuilder;
        private StringBuilder _pathBuilder;
        private StringBuilder _queryBuilder;

        public ClientUriBuilder()
        {
        }

        private UriBuilder UriBuilder => _uriBuilder  ??=  new UriBuilder();

        private StringBuilder PathBuilder => _pathBuilder  ??=  new StringBuilder(UriBuilder.Path);

        private StringBuilder QueryBuilder => _queryBuilder  ??=  new StringBuilder(UriBuilder.Query);

        public void Reset(Uri uri)
        {
            _uriBuilder = new UriBuilder(uri);
            _pathBuilder = new StringBuilder(UriBuilder.Path);
            _queryBuilder = new StringBuilder(UriBuilder.Query);
        }

        public void AppendPath(string value, bool escape)
        {
            if (escape)
            {
                value = Uri.EscapeDataString(value);
            }
            if (PathBuilder.Length > 0 && PathBuilder[PathBuilder.Length - 1] == '/' && value[0] == '/')
            {
                PathBuilder.Remove(PathBuilder.Length - 1, 1);
            }
            PathBuilder.Append(value);
            UriBuilder.Path = PathBuilder.ToString();
        }

        public void AppendPath(bool value, bool escape = false) => AppendPath(TypeFormatters.ConvertToString(value), escape);

        public void AppendPath(float value, bool escape = true) => AppendPath(TypeFormatters.ConvertToString(value), escape);

        public void AppendPath(double value, bool escape = true) => AppendPath(TypeFormatters.ConvertToString(value), escape);

        public void AppendPath(int value, bool escape = true) => AppendPath(TypeFormatters.ConvertToString(value), escape);

        public void AppendPath(byte[] value, string format, bool escape = true) => AppendPath(TypeFormatters.ConvertToString(value, format), escape);

        public void AppendPath(DateTimeOffset value, string format, bool escape = true) => AppendPath(TypeFormatters.ConvertToString(value, format), escape);

        public void AppendPath(TimeSpan value, string format, bool escape = true) => AppendPath(TypeFormatters.ConvertToString(value, format), escape);

        public void AppendPath(Guid value, bool escape = true) => AppendPath(TypeFormatters.ConvertToString(value), escape);

        public void AppendPath(long value, bool escape = true) => AppendPath(TypeFormatters.ConvertToString(value), escape);

        public void AppendPathDelimited<T>(IEnumerable<T> value, string delimiter, string format = null, bool escape = true)
        {
            delimiter ??= ",";
            IEnumerable<string> stringValues = value.Select(v => TypeFormatters.ConvertToString(v, format));
            AppendPath(string.Join(delimiter, stringValues), escape);
        }

        public void AppendQuery(string name, string value, bool escape)
        {
            if (QueryBuilder.Length > 0)
            {
                QueryBuilder.Append('&');
            }
            if (escape)
            {
                value = Uri.EscapeDataString(value);
            }
            QueryBuilder.Append(name);
            QueryBuilder.Append('=');
            QueryBuilder.Append(value);
        }

        public void AppendQuery(string name, bool value, bool escape = false) => AppendQuery(name, TypeFormatters.ConvertToString(value), escape);

        public void AppendQuery(string name, float value, bool escape = true) => AppendQuery(name, TypeFormatters.ConvertToString(value), escape);

        public void AppendQuery(string name, DateTimeOffset value, string format, bool escape = true) => AppendQuery(name, TypeFormatters.ConvertToString(value, format), escape);

        public void AppendQuery(string name, TimeSpan value, string format, bool escape = true) => AppendQuery(name, TypeFormatters.ConvertToString(value, format), escape);

        public void AppendQuery(string name, double value, bool escape = true) => AppendQuery(name, TypeFormatters.ConvertToString(value), escape);

        public void AppendQuery(string name, decimal value, bool escape = true) => AppendQuery(name, TypeFormatters.ConvertToString(value), escape);

        public void AppendQuery(string name, int value, bool escape = true) => AppendQuery(name, TypeFormatters.ConvertToString(value), escape);

        public void AppendQuery(string name, long value, bool escape = true) => AppendQuery(name, TypeFormatters.ConvertToString(value), escape);

        public void AppendQuery(string name, TimeSpan value, bool escape = true) => AppendQuery(name, TypeFormatters.ConvertToString(value), escape);

        public void AppendQuery(string name, byte[] value, string format, bool escape = true) => AppendQuery(name, TypeFormatters.ConvertToString(value, format), escape);

        public void AppendQuery(string name, Guid value, bool escape = true) => AppendQuery(name, TypeFormatters.ConvertToString(value), escape);

        public void AppendQueryDelimited<T>(string name, IEnumerable<T> value, string delimiter, string format = null, bool escape = true)
        {
            delimiter ??= ",";
            IEnumerable<string> stringValues = value.Select(v => TypeFormatters.ConvertToString(v, format));
            AppendQuery(name, string.Join(delimiter, stringValues), escape);
        }

        public Uri ToUri()
        {
            if (_pathBuilder != null)
            {
                UriBuilder.Path = _pathBuilder.ToString();
            }
            if (_queryBuilder != null)
            {
                UriBuilder.Query = _queryBuilder.ToString();
            }
            return UriBuilder.Uri;
        }
    }
}

```

\generated\src\Generated\Internal\ErrorResult.cs:
```
// <auto-generated/>

#nullable disable

using System.ClientModel;
using System.ClientModel.Primitives;

namespace TranlsationService
{
    internal partial class ErrorResult<T> : ClientResult<T>
    {
        private readonly PipelineResponse _response;
        private readonly ClientResultException _exception;

        public ErrorResult(PipelineResponse response, ClientResultException exception) : base(default, response)
        {
            _response = response;
            _exception = exception;
        }

        public override T Value => throw _exception;
    }
}

```

\generated\src\Generated\Internal\ModelSerializationExtensions.cs:
```
// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Text.Json;

namespace TranlsationService
{
    internal static partial class ModelSerializationExtensions
    {
        internal static readonly ModelReaderWriterOptions WireOptions = new ModelReaderWriterOptions("W");

        public static object GetObject(this JsonElement element)
        {
            switch (element.ValueKind)
            {
                case JsonValueKind.String:
                    return element.GetString();
                case JsonValueKind.Number:
                    if (element.TryGetInt32(out int intValue))
                    {
                        return intValue;
                    }
                    if (element.TryGetInt64(out long longValue))
                    {
                        return longValue;
                    }
                    return element.GetDouble();
                case JsonValueKind.True:
                    return true;
                case JsonValueKind.False:
                    return false;
                case JsonValueKind.Undefined:
                case JsonValueKind.Null:
                    return null;
                case JsonValueKind.Object:
                    Dictionary<string, object> dictionary = new Dictionary<string, object>();
                    foreach (var jsonProperty in element.EnumerateObject())
                    {
                        dictionary.Add(jsonProperty.Name, jsonProperty.Value.GetObject());
                    }
                    return dictionary;
                case JsonValueKind.Array:
                    List<object> list = new List<object>();
                    foreach (var item in element.EnumerateArray())
                    {
                        list.Add(item.GetObject());
                    }
                    return list.ToArray();
                default:
                    throw new NotSupportedException($"Not supported value kind {element.ValueKind}");
            }
        }

        public static byte[] GetBytesFromBase64(this JsonElement element, string format)
        {
            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }

            return format switch
            {
                "U" => TypeFormatters.FromBase64UrlString(element.GetRequiredString()),
                "D" => element.GetBytesFromBase64(),
                _ => throw new ArgumentException($"Format is not supported: '{format}'", nameof(format))
            };
        }

        public static DateTimeOffset GetDateTimeOffset(this JsonElement element, string format) => format switch
        {
            "U" when element.ValueKind == JsonValueKind.Number => DateTimeOffset.FromUnixTimeSeconds(element.GetInt64()),
            _ => TypeFormatters.ParseDateTimeOffset(element.GetString(), format)
        };

        public static TimeSpan GetTimeSpan(this JsonElement element, string format) => TypeFormatters.ParseTimeSpan(element.GetString(), format);

        public static char GetChar(this JsonElement element)
        {
            if (element.ValueKind == JsonValueKind.String)
            {
                string text = element.GetString();
                if (text == null || text.Length != 1)
                {
                    throw new NotSupportedException($"Cannot convert \"{text}\" to a char");
                }
                return text[0];
            }
            else
            {
                throw new NotSupportedException($"Cannot convert {element.ValueKind} to a char");
            }
        }

        [Conditional("DEBUG")]
        public static void ThrowNonNullablePropertyIsNull(this JsonProperty @property)
        {
            throw new JsonException($"A property '{@property.Name}' defined as non-nullable but received as null from the service. This exception only happens in DEBUG builds of the library and would be ignored in the release build");
        }

        public static string GetRequiredString(this JsonElement element)
        {
            string value = element.GetString();
            if (value == null)
            {
                throw new InvalidOperationException($"The requested operation requires an element of type 'String', but the target element has type '{element.ValueKind}'.");
            }
            return value;
        }

        public static void WriteStringValue(this Utf8JsonWriter writer, DateTimeOffset value, string format)
        {
            writer.WriteStringValue(TypeFormatters.ToString(value, format));
        }

        public static void WriteStringValue(this Utf8JsonWriter writer, DateTime value, string format)
        {
            writer.WriteStringValue(TypeFormatters.ToString(value, format));
        }

        public static void WriteStringValue(this Utf8JsonWriter writer, TimeSpan value, string format)
        {
            writer.WriteStringValue(TypeFormatters.ToString(value, format));
        }

        public static void WriteStringValue(this Utf8JsonWriter writer, char value)
        {
            writer.WriteStringValue(value.ToString(CultureInfo.InvariantCulture));
        }

        public static void WriteBase64StringValue(this Utf8JsonWriter writer, byte[] value, string format)
        {
            if (value == null)
            {
                writer.WriteNullValue();
                return;
            }
            switch (format)
            {
                case "U":
                    writer.WriteStringValue(TypeFormatters.ToBase64UrlString(value));
                    break;
                case "D":
                    writer.WriteBase64StringValue(value);
                    break;
                default:
                    throw new ArgumentException($"Format is not supported: '{format}'", nameof(format));
            }
        }

        public static void WriteNumberValue(this Utf8JsonWriter writer, DateTimeOffset value, string format)
        {
            if (format != "U")
            {
                throw new ArgumentOutOfRangeException(nameof(format), "Only 'U' format is supported when writing a DateTimeOffset as a Number.");
            }
            writer.WriteNumberValue(value.ToUnixTimeSeconds());
        }

        public static void WriteObjectValue<T>(this Utf8JsonWriter writer, T value, ModelReaderWriterOptions options = null)
        {
            switch (value)
            {
                case null:
                    writer.WriteNullValue();
                    break;
                case IJsonModel<T> jsonModel:
                    jsonModel.Write(writer, options ?? WireOptions);
                    break;
                case byte[] bytes:
                    writer.WriteBase64StringValue(bytes);
                    break;
                case BinaryData bytes0:
                    writer.WriteBase64StringValue(bytes0);
                    break;
                case JsonElement json:
                    json.WriteTo(writer);
                    break;
                case int i:
                    writer.WriteNumberValue(i);
                    break;
                case decimal d:
                    writer.WriteNumberValue(d);
                    break;
                case double d0:
                    if (double.IsNaN(d0))
                    {
                        writer.WriteStringValue("NaN");
                    }
                    else
                    {
                        writer.WriteNumberValue(d0);
                    }
                    break;
                case float f:
                    writer.WriteNumberValue(f);
                    break;
                case long l:
                    writer.WriteNumberValue(l);
                    break;
                case string s:
                    writer.WriteStringValue(s);
                    break;
                case bool b:
                    writer.WriteBooleanValue(b);
                    break;
                case Guid g:
                    writer.WriteStringValue(g);
                    break;
                case DateTimeOffset dateTimeOffset:
                    writer.WriteStringValue(dateTimeOffset, "O");
                    break;
                case DateTime dateTime:
                    writer.WriteStringValue(dateTime, "O");
                    break;
                case IEnumerable<KeyValuePair<string, object>> enumerable:
                    writer.WriteStartObject();
                    foreach (var pair in enumerable)
                    {
                        writer.WritePropertyName(pair.Key);
                        writer.WriteObjectValue<object>(pair.Value, options);
                    }
                    writer.WriteEndObject();
                    break;
                case IEnumerable<object> objectEnumerable:
                    writer.WriteStartArray();
                    foreach (var item in objectEnumerable)
                    {
                        writer.WriteObjectValue<object>(item, options);
                    }
                    writer.WriteEndArray();
                    break;
                case TimeSpan timeSpan:
                    writer.WriteStringValue(timeSpan, "P");
                    break;
                default:
                    throw new NotSupportedException($"Not supported type {value.GetType()}");
            }
        }

        public static void WriteObjectValue(this Utf8JsonWriter writer, object value, ModelReaderWriterOptions options = null)
        {
            writer.WriteObjectValue<object>(value, options);
        }
    }
}

```

\generated\src\Generated\Internal\MultiPartFormDataBinaryContent.cs:
```
// <auto-generated/>

#nullable disable

using System;
using System.ClientModel;
using System.Globalization;
using System.IO;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Threading;
using System.Threading.Tasks;

namespace TranlsationService
{
    internal partial class MultiPartFormDataBinaryContent : BinaryContent
    {
        private readonly MultipartFormDataContent _multipartContent;
        private static readonly Random _random = new Random();
        private static readonly char[] _boundaryValues = "0123456789=ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".ToCharArray();

        public MultiPartFormDataBinaryContent()
        {
            _multipartContent = new MultipartFormDataContent(CreateBoundary());
        }

        public string ContentType
        {
            get
            {
                return _multipartContent.Headers.ContentType.ToString();
            }
        }

        internal HttpContent HttpContent => _multipartContent;

        private static string CreateBoundary()
        {
            Span<char> chars = new char[70];
            byte[] random = new byte[70];
            _random.NextBytes(random);
            int mask = 255 >> 2;
            int i = 0;
            for (; i < 70; i++)
            {
                chars[i] = _boundaryValues[random[i] & mask];
            }
            return chars.ToString();
        }

        public void Add(string content, string name, string filename = default, string contentType = default)
        {
            Argument.AssertNotNull(content, nameof(content));
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            Add(new StringContent(content), name, filename, contentType);
        }

        public void Add(int content, string name, string filename = default, string contentType = default)
        {
            Argument.AssertNotNull(content, nameof(content));
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            string value = content.ToString("G", CultureInfo.InvariantCulture);
            Add(new StringContent(value), name, filename, contentType);
        }

        public void Add(long content, string name, string filename = default, string contentType = default)
        {
            Argument.AssertNotNull(content, nameof(content));
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            string value = content.ToString("G", CultureInfo.InvariantCulture);
            Add(new StringContent(value), name, filename, contentType);
        }

        public void Add(float content, string name, string filename = default, string contentType = default)
        {
            Argument.AssertNotNull(content, nameof(content));
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            string value = content.ToString("G", CultureInfo.InvariantCulture);
            Add(new StringContent(value), name, filename, contentType);
        }

        public void Add(double content, string name, string filename = default, string contentType = default)
        {
            Argument.AssertNotNull(content, nameof(content));
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            string value = content.ToString("G", CultureInfo.InvariantCulture);
            Add(new StringContent(value), name, filename, contentType);
        }

        public void Add(decimal content, string name, string filename = default, string contentType = default)
        {
            Argument.AssertNotNull(content, nameof(content));
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            string value = content.ToString("G", CultureInfo.InvariantCulture);
            Add(new StringContent(value), name, filename, contentType);
        }

        public void Add(bool content, string name, string filename = default, string contentType = default)
        {
            Argument.AssertNotNull(content, nameof(content));
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            string value = content ? "true" : "false";
            Add(new StringContent(value), name, filename, contentType);
        }

        public void Add(Stream content, string name, string filename = default, string contentType = default)
        {
            Argument.AssertNotNull(content, nameof(content));
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            Add(new StreamContent(content), name, filename, contentType);
        }

        public void Add(byte[] content, string name, string filename = default, string contentType = default)
        {
            Argument.AssertNotNull(content, nameof(content));
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            Add(new ByteArrayContent(content), name, filename, contentType);
        }

        public void Add(BinaryData content, string name, string filename = default, string contentType = default)
        {
            Argument.AssertNotNull(content, nameof(content));
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            Add(new ByteArrayContent(content.ToArray()), name, filename, contentType);
        }

        private void Add(HttpContent content, string name, string filename, string contentType)
        {
            if (contentType != null)
            {
                Argument.AssertNotNullOrEmpty(contentType, nameof(contentType));
                AddContentTypeHeader(content, contentType);
            }
            if (filename != null)
            {
                Argument.AssertNotNullOrEmpty(filename, nameof(filename));
                _multipartContent.Add(content, name, filename);
            }
            else
            {
                _multipartContent.Add(content, name);
            }
        }

        public static void AddContentTypeHeader(HttpContent content, string contentType)
        {
            MediaTypeHeaderValue header = new MediaTypeHeaderValue(contentType);
            content.Headers.ContentType = header;
        }

        public override bool TryComputeLength(out long length)
        {
            if (_multipartContent.Headers.ContentLength is long contentLength)
            {
                length = contentLength;
                return true;
            }
            length = 0;
            return false;
        }

        public override void WriteTo(Stream stream, CancellationToken cancellationToken = default)
        {
#if NET6_0_OR_GREATER
            _multipartContent.CopyTo(stream, default, cancellationToken);
#else
            _multipartContent.CopyToAsync(stream).GetAwaiter().GetResult();
#endif
        }

        public override async Task WriteToAsync(Stream stream, CancellationToken cancellationToken = default)
        {
#if NET6_0_OR_GREATER
            await _multipartContent.CopyToAsync(stream).ConfigureAwait(false);
#else
            await _multipartContent.CopyToAsync(stream).ConfigureAwait(false);
#endif
        }

        public override void Dispose()
        {
            _multipartContent.Dispose();
        }
    }
}

```

\generated\src\Generated\Internal\TypeFormatters.cs:
```
// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Xml;

namespace TranlsationService
{
    internal static partial class TypeFormatters
    {
        private const string RoundtripZFormat = "yyyy-MM-ddTHH:mm:ss.fffffffZ";
        public const string DefaultNumberFormat = "G";

        public static string ToString(bool value) => value ? "true" : "false";

        public static string ToString(DateTime value, string format) => value.Kind switch
        {
            DateTimeKind.Utc => ToString((DateTimeOffset)value, format),
            _ => throw new NotSupportedException($"DateTime {value} has a Kind of {value.Kind}. Generated clients require it to be UTC. You can call DateTime.SpecifyKind to change Kind property value to DateTimeKind.Utc.")
        };

        public static string ToString(DateTimeOffset value, string format) => format switch
        {
            "D" => value.ToString("yyyy-MM-dd", CultureInfo.InvariantCulture),
            "U" => value.ToUnixTimeSeconds().ToString(CultureInfo.InvariantCulture),
            "O" => value.ToUniversalTime().ToString(RoundtripZFormat, CultureInfo.InvariantCulture),
            "o" => value.ToUniversalTime().ToString(RoundtripZFormat, CultureInfo.InvariantCulture),
            "R" => value.ToString("r", CultureInfo.InvariantCulture),
            _ => value.ToString(format, CultureInfo.InvariantCulture)
        };

        public static string ToString(TimeSpan value, string format) => format switch
        {
            "P" => System.Xml.XmlConvert.ToString(value),
            _ => value.ToString(format, CultureInfo.InvariantCulture)
        };

        public static string ToString(byte[] value, string format) => format switch
        {
            "U" => ToBase64UrlString(value),
            "D" => Convert.ToBase64String(value),
            _ => throw new ArgumentException($"Format is not supported: '{format}'", nameof(format))
        };

        public static string ToBase64UrlString(byte[] value)
        {
            int numWholeOrPartialInputBlocks = checked (value.Length + 2) / 3;
            int size = checked (numWholeOrPartialInputBlocks * 4);
            char[] output = new char[size];

            int numBase64Chars = Convert.ToBase64CharArray(value, 0, value.Length, output, 0);

            int i = 0;
            for (; i < numBase64Chars; i++)
            {
                char ch = output[i];
                if (ch == '+')
                {
                    output[i] = '-';
                }
                else
                {
                    if (ch == '/')
                    {
                        output[i] = '_';
                    }
                    else
                    {
                        if (ch == '=')
                        {
                            break;
                        }
                    }
                }
            }

            return new string(output, 0, i);
        }

        public static byte[] FromBase64UrlString(string value)
        {
            int paddingCharsToAdd = (value.Length % 4) switch
            {
                0 => 0,
                2 => 2,
                3 => 1,
                _ => throw new InvalidOperationException("Malformed input")
            };
            char[] output = new char[(value.Length + paddingCharsToAdd)];
            int i = 0;
            for (; i < value.Length; i++)
            {
                char ch = value[i];
                if (ch == '-')
                {
                    output[i] = '+';
                }
                else
                {
                    if (ch == '_')
                    {
                        output[i] = '/';
                    }
                    else
                    {
                        output[i] = ch;
                    }
                }
            }

            for (; i < output.Length; i++)
            {
                output[i] = '=';
            }

            return Convert.FromBase64CharArray(output, 0, output.Length);
        }

        public static DateTimeOffset ParseDateTimeOffset(string value, string format) => format switch
        {
            "U" => DateTimeOffset.FromUnixTimeSeconds(long.Parse(value, CultureInfo.InvariantCulture)),
            _ => DateTimeOffset.Parse(value, CultureInfo.InvariantCulture, DateTimeStyles.AssumeUniversal)
        };

        public static TimeSpan ParseTimeSpan(string value, string format) => format switch
        {
            "P" => System.Xml.XmlConvert.ToTimeSpan(value),
            _ => TimeSpan.ParseExact(value, format, CultureInfo.InvariantCulture)
        };

        public static string ConvertToString(object value, string format = null) => value switch
        {
            null => "null",
            string s => s,
            bool b => ToString(b),
            int  or  float  or  double  or  long  or  decimal => ((IFormattable)value).ToString(DefaultNumberFormat, CultureInfo.InvariantCulture),
            byte[] b0 when format != null => ToString(b0, format),
            IEnumerable<string> s0 => string.Join(",", s0),
            DateTimeOffset dateTime when format != null => ToString(dateTime, format),
            TimeSpan timeSpan when format != null => ToString(timeSpan, format),
            TimeSpan timeSpan0 => System.Xml.XmlConvert.ToString(timeSpan0),
            Guid guid => guid.ToString(),
            BinaryData binaryData => ConvertToString(binaryData.ToArray(), format),
            _ => value.ToString()
        };
    }
}

```

\generated\src\Generated\Models\Payment.cs:
```
// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using TranlsationService;

namespace TranlsationService.Models
{
    /// <summary> The Payment. </summary>
    public partial class Payment
    {
        /// <summary> Keeps track of any properties unknown to the library. </summary>
        private protected readonly IDictionary<string, BinaryData> _additionalBinaryDataProperties;

        /// <summary> Initializes a new instance of <see cref="Payment"/>. </summary>
        /// <param name="userEmail"></param>
        /// <param name="amount"></param>
        /// <param name="service"></param>
        /// <param name="userId"></param>
        /// <param name="synthesizedAudio"></param>
        /// <exception cref="ArgumentNullException"> <paramref name="userEmail"/>, <paramref name="service"/> or <paramref name="userId"/> is null. </exception>
        public Payment(string userEmail, float amount, string service, string userId, bool synthesizedAudio)
        {
            Argument.AssertNotNull(userEmail, nameof(userEmail));
            Argument.AssertNotNull(service, nameof(service));
            Argument.AssertNotNull(userId, nameof(userId));

            UserEmail = userEmail;
            Amount = amount;
            Service = service;
            UserId = userId;
            SynthesizedAudio = synthesizedAudio;
        }

        internal Payment(string userEmail, float amount, string service, string userId, bool synthesizedAudio, IDictionary<string, BinaryData> additionalBinaryDataProperties)
        {
            UserEmail = userEmail;
            Amount = amount;
            Service = service;
            UserId = userId;
            SynthesizedAudio = synthesizedAudio;
            _additionalBinaryDataProperties = additionalBinaryDataProperties;
        }

        /// <summary> Gets the UserEmail. </summary>
        public string UserEmail { get; }

        /// <summary> Gets the Amount. </summary>
        public float Amount { get; }

        /// <summary> Gets the Service. </summary>
        public string Service { get; }

        /// <summary> Gets the UserId. </summary>
        public string UserId { get; }

        /// <summary> Gets the SynthesizedAudio. </summary>
        public bool SynthesizedAudio { get; }
    }
}

```

\generated\src\Generated\Models\Payment.Serialization.cs:
```
// <auto-generated/>

#nullable disable

using System;
using System.ClientModel;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using TranlsationService;

namespace TranlsationService.Models
{
    /// <summary></summary>
    public partial class Payment : IJsonModel<Payment>
    {
        internal Payment()
        {
        }

        void IJsonModel<Payment>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<Payment>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(Payment)} does not support writing '{format}' format.");
            }
            writer.WritePropertyName("userEmail"u8);
            writer.WriteStringValue(UserEmail);
            writer.WritePropertyName("amount"u8);
            writer.WriteNumberValue(Amount);
            writer.WritePropertyName("service"u8);
            writer.WriteStringValue(Service);
            writer.WritePropertyName("userId"u8);
            writer.WriteStringValue(UserId);
            writer.WritePropertyName("synthesizedAudio"u8);
            writer.WriteBooleanValue(SynthesizedAudio);
            if (options.Format != "W" && _additionalBinaryDataProperties != null)
            {
                foreach (var item in _additionalBinaryDataProperties)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
                    writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        Payment IJsonModel<Payment>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) => JsonModelCreateCore(ref reader, options);

        /// <param name="reader"> The JSON reader. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual Payment JsonModelCreateCore(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<Payment>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(Payment)} does not support reading '{format}' format.");
            }
            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializePayment(document.RootElement, options);
        }

        internal static Payment DeserializePayment(JsonElement element, ModelReaderWriterOptions options)
        {
            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string userEmail = default;
            float amount = default;
            string service = default;
            string userId = default;
            bool synthesizedAudio = default;
            IDictionary<string, BinaryData> additionalBinaryDataProperties = new ChangeTrackingDictionary<string, BinaryData>();
            foreach (var prop in element.EnumerateObject())
            {
                if (prop.NameEquals("userEmail"u8))
                {
                    userEmail = prop.Value.GetString();
                    continue;
                }
                if (prop.NameEquals("amount"u8))
                {
                    amount = prop.Value.GetSingle();
                    continue;
                }
                if (prop.NameEquals("service"u8))
                {
                    service = prop.Value.GetString();
                    continue;
                }
                if (prop.NameEquals("userId"u8))
                {
                    userId = prop.Value.GetString();
                    continue;
                }
                if (prop.NameEquals("synthesizedAudio"u8))
                {
                    synthesizedAudio = prop.Value.GetBoolean();
                    continue;
                }
                if (options.Format != "W")
                {
                    additionalBinaryDataProperties.Add(prop.Name, BinaryData.FromString(prop.Value.GetRawText()));
                }
            }
            return new Payment(
                userEmail,
                amount,
                service,
                userId,
                synthesizedAudio,
                additionalBinaryDataProperties);
        }

        BinaryData IPersistableModel<Payment>.Write(ModelReaderWriterOptions options) => PersistableModelWriteCore(options);

        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual BinaryData PersistableModelWriteCore(ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<Payment>)this).GetFormatFromOptions(options) : options.Format;
            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options);
                default:
                    throw new FormatException($"The model {nameof(Payment)} does not support writing '{options.Format}' format.");
            }
        }

        Payment IPersistableModel<Payment>.Create(BinaryData data, ModelReaderWriterOptions options) => PersistableModelCreateCore(data, options);

        /// <param name="data"> The data to parse. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual Payment PersistableModelCreateCore(BinaryData data, ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<Payment>)this).GetFormatFromOptions(options) : options.Format;
            switch (format)
            {
                case "J":
                    using (JsonDocument document = JsonDocument.Parse(data))
                    {
                        return DeserializePayment(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(Payment)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<Payment>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";

        /// <param name="payment"> The <see cref="Payment"/> to serialize into <see cref="BinaryContent"/>. </param>
        public static implicit operator BinaryContent(Payment payment)
        {
            if (payment == null)
            {
                return null;
            }
            return BinaryContent.Create(payment, ModelSerializationExtensions.WireOptions);
        }

        /// <param name="result"> The <see cref="ClientResult"/> to deserialize the <see cref="Payment"/> from. </param>
        public static explicit operator Payment(ClientResult result)
        {
            using PipelineResponse response = result.GetRawResponse();
            using JsonDocument document = JsonDocument.Parse(response.Content);
            return DeserializePayment(document.RootElement, ModelSerializationExtensions.WireOptions);
        }
    }
}

```

\generated\src\Generated\Models\PaymentResponse.cs:
```
// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace TranlsationService.Models
{
    /// <summary> The PaymentResponse. </summary>
    public partial class PaymentResponse
    {
        /// <summary> Keeps track of any properties unknown to the library. </summary>
        private protected readonly IDictionary<string, BinaryData> _additionalBinaryDataProperties;

        internal PaymentResponse(string message, string userId)
        {
            Message = message;
            UserId = userId;
        }

        internal PaymentResponse(string message, string userId, IDictionary<string, BinaryData> additionalBinaryDataProperties)
        {
            Message = message;
            UserId = userId;
            _additionalBinaryDataProperties = additionalBinaryDataProperties;
        }

        /// <summary> Gets the Message. </summary>
        public string Message { get; }

        /// <summary> Gets the UserId. </summary>
        public string UserId { get; }
    }
}

```

\generated\src\Generated\Models\PaymentResponse.Serialization.cs:
```
// <auto-generated/>

#nullable disable

using System;
using System.ClientModel;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using TranlsationService;

namespace TranlsationService.Models
{
    /// <summary></summary>
    public partial class PaymentResponse : IJsonModel<PaymentResponse>
    {
        internal PaymentResponse()
        {
        }

        void IJsonModel<PaymentResponse>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<PaymentResponse>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(PaymentResponse)} does not support writing '{format}' format.");
            }
            writer.WritePropertyName("message"u8);
            writer.WriteStringValue(Message);
            writer.WritePropertyName("userId"u8);
            writer.WriteStringValue(UserId);
            if (options.Format != "W" && _additionalBinaryDataProperties != null)
            {
                foreach (var item in _additionalBinaryDataProperties)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
                    writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        PaymentResponse IJsonModel<PaymentResponse>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) => JsonModelCreateCore(ref reader, options);

        /// <param name="reader"> The JSON reader. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual PaymentResponse JsonModelCreateCore(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<PaymentResponse>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(PaymentResponse)} does not support reading '{format}' format.");
            }
            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializePaymentResponse(document.RootElement, options);
        }

        internal static PaymentResponse DeserializePaymentResponse(JsonElement element, ModelReaderWriterOptions options)
        {
            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string message = default;
            string userId = default;
            IDictionary<string, BinaryData> additionalBinaryDataProperties = new ChangeTrackingDictionary<string, BinaryData>();
            foreach (var prop in element.EnumerateObject())
            {
                if (prop.NameEquals("message"u8))
                {
                    message = prop.Value.GetString();
                    continue;
                }
                if (prop.NameEquals("userId"u8))
                {
                    userId = prop.Value.GetString();
                    continue;
                }
                if (options.Format != "W")
                {
                    additionalBinaryDataProperties.Add(prop.Name, BinaryData.FromString(prop.Value.GetRawText()));
                }
            }
            return new PaymentResponse(message, userId, additionalBinaryDataProperties);
        }

        BinaryData IPersistableModel<PaymentResponse>.Write(ModelReaderWriterOptions options) => PersistableModelWriteCore(options);

        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual BinaryData PersistableModelWriteCore(ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<PaymentResponse>)this).GetFormatFromOptions(options) : options.Format;
            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options);
                default:
                    throw new FormatException($"The model {nameof(PaymentResponse)} does not support writing '{options.Format}' format.");
            }
        }

        PaymentResponse IPersistableModel<PaymentResponse>.Create(BinaryData data, ModelReaderWriterOptions options) => PersistableModelCreateCore(data, options);

        /// <param name="data"> The data to parse. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual PaymentResponse PersistableModelCreateCore(BinaryData data, ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<PaymentResponse>)this).GetFormatFromOptions(options) : options.Format;
            switch (format)
            {
                case "J":
                    using (JsonDocument document = JsonDocument.Parse(data))
                    {
                        return DeserializePaymentResponse(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(PaymentResponse)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<PaymentResponse>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";

        /// <param name="paymentResponse"> The <see cref="PaymentResponse"/> to serialize into <see cref="BinaryContent"/>. </param>
        public static implicit operator BinaryContent(PaymentResponse paymentResponse)
        {
            if (paymentResponse == null)
            {
                return null;
            }
            return BinaryContent.Create(paymentResponse, ModelSerializationExtensions.WireOptions);
        }

        /// <param name="result"> The <see cref="ClientResult"/> to deserialize the <see cref="PaymentResponse"/> from. </param>
        public static explicit operator PaymentResponse(ClientResult result)
        {
            using PipelineResponse response = result.GetRawResponse();
            using JsonDocument document = JsonDocument.Parse(response.Content);
            return DeserializePaymentResponse(document.RootElement, ModelSerializationExtensions.WireOptions);
        }
    }
}

```

\generated\src\obj\Debug\net9.0\.NETCoreApp,Version=v9.0.AssemblyAttributes.cs:
```
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName = ".NET 9.0")]

```

\generated\src\obj\Debug\net9.0\TranlsationService.AssemblyInfo.cs:
```
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("TranlsationService")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyDescriptionAttribute(("This is the TranlsationService client library for developing .NET applications wi" +
    "th rich experience."))]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0-beta.1+30d4f945914f1101cfb5d624d57bd15a29f72065")]
[assembly: System.Reflection.AssemblyProductAttribute("TranlsationService")]
[assembly: System.Reflection.AssemblyTitleAttribute("SDK Code Generation TranlsationService")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


```

\generated\src\obj\Debug\netstandard2.0\.NETStandard,Version=v2.0.AssemblyAttributes.cs:
```
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETStandard,Version=v2.0", FrameworkDisplayName = ".NET Standard 2.0")]

```

\generated\src\obj\Debug\netstandard2.0\TranlsationService.AssemblyInfo.cs:
```
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("TranlsationService")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyDescriptionAttribute(("This is the TranlsationService client library for developing .NET applications wi" +
    "th rich experience."))]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0-beta.1+30d4f945914f1101cfb5d624d57bd15a29f72065")]
[assembly: System.Reflection.AssemblyProductAttribute("TranlsationService")]
[assembly: System.Reflection.AssemblyTitleAttribute("SDK Code Generation TranlsationService")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


```

