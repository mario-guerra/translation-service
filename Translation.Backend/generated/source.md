\controllers\NotificationsOperationsControllerBase.cs:
```
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// <auto-generated />

using System;
using System.Net;
using System.Threading.Tasks;
using System.Text.Json;
using System.Text.Json.Serialization;
using Microsoft.AspNetCore.Mvc;
using AudioTranslationService.Models.Service.Models;
using AudioTranslationService.Models.Service;

namespace AudioTranslationService.Models.Service.Controllers
{
    [ApiController]
    public abstract partial class NotificationsOperationsControllerBase : ControllerBase
    {

        internal abstract INotificationsOperations NotificationsOperationsImpl { get; }


        [HttpPost]
        [Route("/notifications")]
        [ProducesResponseType((int)HttpStatusCode.OK, Type = typeof(string))]
        public virtual async Task<IActionResult> ManageNotifications(NotificationPreferences body)
        {
            var result = await NotificationsOperationsImpl.ManageNotificationsAsync(body);
            return Ok(result);
        }

    }
}

```

\controllers\OperationsOperationsControllerBase.cs:
```
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// <auto-generated />

using System;
using System.Net;
using System.Threading.Tasks;
using System.Text.Json;
using System.Text.Json.Serialization;
using Microsoft.AspNetCore.Mvc;
using AudioTranslationService.Models.Service.Models;
using AudioTranslationService.Models.Service;

namespace AudioTranslationService.Models.Service.Controllers
{
    [ApiController]
    public abstract partial class OperationsOperationsControllerBase : ControllerBase
    {

        internal abstract IOperationsOperations OperationsOperationsImpl { get; }


        [HttpGet]
        [Route("/user/profile")]
        [ProducesResponseType((int)HttpStatusCode.OK, Type = typeof(User))]
        public virtual async Task<IActionResult> GetUserProfile()
        {
            var result = await OperationsOperationsImpl.GetUserProfileAsync();
            return Ok(result);
        }


        [HttpPut]
        [Route("/user/profile")]
        [ProducesResponseType((int)HttpStatusCode.OK, Type = typeof(string))]
        public virtual async Task<IActionResult> UpdateUserProfile(User body)
        {
            var result = await OperationsOperationsImpl.UpdateUserProfileAsync(body);
            return Ok(result);
        }


        [HttpGet]
        [Route("/upload/{uploadId}")]
        [ProducesResponseType((int)HttpStatusCode.OK, Type = typeof(AudioUpload))]
        public virtual async Task<IActionResult> GetUploadDetails(string uploadId)
        {
            var result = await OperationsOperationsImpl.GetUploadDetailsAsync(uploadId);
            return Ok(result);
        }


        [HttpDelete]
        [Route("/upload/{uploadId}")]
        [ProducesResponseType((int)HttpStatusCode.OK, Type = typeof(string))]
        public virtual async Task<IActionResult> DeleteUpload(string uploadId)
        {
            var result = await OperationsOperationsImpl.DeleteUploadAsync(uploadId);
            return Ok(result);
        }


        [HttpGet]
        [Route("/jobs")]
        [ProducesResponseType((int)HttpStatusCode.OK, Type = typeof(void))]
        public virtual async Task<IActionResult> ListJobs()
        {
            await OperationsOperationsImpl.ListJobsAsync();
            return Ok();
        }


        [HttpDelete]
        [Route("/job/{jobId}")]
        [ProducesResponseType((int)HttpStatusCode.OK, Type = typeof(string))]
        public virtual async Task<IActionResult> CancelJob(string jobId)
        {
            var result = await OperationsOperationsImpl.CancelJobAsync(jobId);
            return Ok(result);
        }

    }
}

```

\controllers\RoutesOperationsControllerBase.cs:
```
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// <auto-generated />

using System;
using System.Net;
using System.Threading.Tasks;
using System.Text.Json;
using System.Text.Json.Serialization;
using Microsoft.AspNetCore.Mvc;
using AudioTranslationService.Models.Service.Models;
using AudioTranslationService.Models.Service;

namespace AudioTranslationService.Models.Service.Controllers
{
    [ApiController]
    public abstract partial class RoutesOperationsControllerBase : ControllerBase
    {

        internal abstract IRoutesOperations RoutesOperationsImpl { get; }


        [HttpPost]
        [Route("/register")]
        [ProducesResponseType((int)HttpStatusCode.OK, Type = typeof(User))]
        public virtual async Task<IActionResult> Register(User body)
        {
            var result = await RoutesOperationsImpl.RegisterAsync(body);
            return Ok(result);
        }


        [HttpPost]
        [Route("/login")]
        [ProducesResponseType((int)HttpStatusCode.OK, Type = typeof(string))]
        public virtual async Task<IActionResult> Login(User body)
        {
            var result = await RoutesOperationsImpl.LoginAsync(body);
            return Ok(result);
        }


        [HttpPost]
        [Route("/payment")]
        [ProducesResponseType((int)HttpStatusCode.OK, Type = typeof(Payment))]
        public virtual async Task<IActionResult> ProcessPayment(Payment body)
        {
            var result = await RoutesOperationsImpl.ProcessPaymentAsync(body);
            return Ok(result);
        }


        [HttpPost]
        [Route("/upload-audio")]
        [ProducesResponseType((int)HttpStatusCode.OK, Type = typeof(AudioUpload))]
        public virtual async Task<IActionResult> UploadAudio(AudioUpload body)
        {
            var result = await RoutesOperationsImpl.UploadAudioAsync(body);
            return Ok(result);
        }


        [HttpPost]
        [Route("/translate")]
        [ProducesResponseType((int)HttpStatusCode.OK, Type = typeof(TranslationJob))]
        public virtual async Task<IActionResult> StartTranslation(TranslationJob body)
        {
            var result = await RoutesOperationsImpl.StartTranslationAsync(body);
            return Ok(result);
        }


        [HttpGet]
        [Route("/status/{jobId}")]
        [ProducesResponseType((int)HttpStatusCode.OK, Type = typeof(TranslationJob))]
        public virtual async Task<IActionResult> CheckStatus(string jobId)
        {
            var result = await RoutesOperationsImpl.CheckStatusAsync(jobId);
            return Ok(result);
        }


        [HttpGet]
        [Route("/download/{jobId}")]
        [ProducesResponseType((int)HttpStatusCode.OK, Type = typeof(byte[]))]
        public virtual async Task<IActionResult> DownloadArtifact(string jobId)
        {
            var result = await RoutesOperationsImpl.DownloadArtifactAsync(jobId);
            return Ok(result);
        }

    }
}

```

\lib\ArrayConstraintAttribute.cs:
```
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// <auto-generated />
#nullable enable

using System.Text.Json;
using System.Text.Json.Serialization;

namespace TypeSpec.Helpers.JsonConverters
{
    /// <summary>
    /// Constrains the number of elements in an array
    /// </summary>
    /// <typeparam name="T">The element type of the array</typeparam>
    public class ArrayConstraintAttribute<T> : JsonConverterAttribute
    {
        int? _minItems = null, _maxItems = null;
        /// <summary>
        /// The smallest number of allowed items
        /// </summary>
        public int MinItems { get { return _minItems.HasValue ? _minItems.Value : 0; } set { _minItems = value; } }
        /// <summary>
        /// The largest number of allowed items
        /// </summary>
        public int MaxItems { get { return _maxItems.HasValue ? _maxItems.Value : 0; } set { _maxItems = value; } }

        public ArrayConstraintAttribute()
        {

        }

        public override JsonConverter? CreateConverter(Type typeToConvert)
        {
            return new ConstrainedArrayConverter<T>(_minItems, _maxItems);
        }


    }

    public class ConstrainedArrayConverter<T> : JsonConverter<T[]>
    {
        public ConstrainedArrayConverter(int? min, int? max) : base()
        {
            _minItems = min;
            _maxItems = max;
        }

        internal int? _minItems, _maxItems;
        public JsonConverter<T>? InnerConverter { get; set; }

        public virtual Func<ConstrainedArrayConverter<T>, JsonSerializerOptions, JsonConverter<T>> InnerConverterFactory { get; set; } = ConverterHelpers.GetStandardInnerConverter<T>;


        internal bool ValidateMin(int count)
        {
            return !_minItems.HasValue || count >= _minItems.Value;
        }

        internal bool ValidateMax(int count)
        {
            return !_maxItems.HasValue || count <= _maxItems.Value;
        }

        internal void ValidateRange(int count)
        {
            if (!ValidateMax(count) || !ValidateMin(count))
            {
                throw new JsonException($"Number of array elements not in range [{(_minItems.HasValue ? _minItems.Value : 0)}, {(_maxItems.HasValue ? _maxItems.Value : Array.MaxLength)}]");
            }
        }
        public override T[]? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var _innerConverter = InnerConverterFactory(this, options);
            if (reader.TokenType != JsonTokenType.StartArray) { throw new JsonException("Expected start of array"); }
            var list = new List<T>();
            int count = 0;
            while (reader.Read())
            {
                if (reader.TokenType == JsonTokenType.EndArray) { ValidateRange(count); break; }
                if (!ValidateMax(count)) { ValidateRange(count); break; }
                T value = _innerConverter.Read(ref reader, typeof(T), options)!;
                list.Add(value);
                count++;
            }

            return list.ToArray();


        }

        public override void Write(Utf8JsonWriter writer, T[] value, JsonSerializerOptions options)
        {
            var _innerConverter = InnerConverterFactory(this, options);
            writer.WriteStartArray();
            for (int i = 0; i < value.Length; ++i)
                _innerConverter.Write(writer, value[i], options);
            writer.WriteEndArray();
        }
    }

    internal static class ConverterHelpers
    {
        internal static JsonConverter<T> GetStandardInnerConverter<T>(this ConstrainedArrayConverter<T> converter, JsonSerializerOptions options)
        {
            if (converter.InnerConverter == null)
            {
                converter.InnerConverter = (JsonConverter<T>)options.GetConverter(typeof(T));
            }

            return converter.InnerConverter;
        }
    }
}
```

\lib\Base64UrlConverter.cs:
```
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// <auto-generated />
#nullable enable

using System.Text.Json;
using System.Text.Json.Serialization;

namespace TypeSpec.Helpers.JsonConverters
{
    /// <summary>
    /// System.Text.Json converter for the properties using Base64Url encoding
    /// </summary>
    public class Base64UrlJsonConverter : JsonConverter<byte[]>
    {
        /// <summary>
        /// Adds padding to the input
        /// </summary>
        /// <param name="input"> the input string </param>
        /// <returns> the padded string </returns>
        private static string Pad(string input)
        {
            var count = 3 - ((input.Length + 3) % 4);
            if (count == 0)
            {
                return input;
            }
            return $"{input}{new string('=', count)}";
        }

        public override byte[]? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            if (typeToConvert != typeof(byte[])) throw new ArgumentException($"Cannot apply converter {this.GetType().FullName} to type {typeToConvert.FullName}");
            var value = reader.GetString();
            if (string.IsNullOrWhiteSpace(value)) return null;
            return Convert.FromBase64String(Pad(value.Replace('-', '+').Replace('_', '/')));
        }

        public override void Write(Utf8JsonWriter writer, byte[] value, JsonSerializerOptions options)
        {
            writer.WriteStringValue(Convert.ToBase64String(value).TrimEnd('=').Replace('+', '-').Replace('/', '_'));
        }
    }
}

```

\lib\NumericArrayConstraintAttribute.cs:
```
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// <auto-generated />
#nullable enable

using System.Numerics;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace TypeSpec.Helpers.JsonConverters
{
    /// <summary>
    /// Constrains an array and the item types within it
    /// </summary>
    /// <typeparam name="T">The item type</typeparam>
    public class NumericArrayConstraintAttribute<T> : ArrayConstraintAttribute<T> where T : struct, INumber<T>
    {
        T? _minValue = null, _maxValue = null;
        public NumericArrayConstraintAttribute() : base()
        {
        }

        public T MinValue { get { return _minValue.HasValue ? _minValue.Value : default(T); } set { _minValue = value; } }
        public T MaxValue { get { return _maxValue.HasValue ? _maxValue.Value : default(T); } set { _maxValue = value; } }
        bool MinValueExclusive { get; set; }
        bool MaxValueExclusive { get; set; }

        public override JsonConverter? CreateConverter(Type typeToConvert)
        {
            var result = base.CreateConverter(typeToConvert) as ConstrainedArrayConverter<T>;
            if (result != null) result.InnerConverterFactory = (c, o) => new NumericJsonConverter<T>(MinValue, MaxValue, MinValueExclusive, MaxValueExclusive, o);
            return result;
        }
    }
}
```

\lib\NumericConstraintAttribute.cs:
```
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// <auto-generated />
#nullable enable

using System.Numerics;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace TypeSpec.Helpers.JsonConverters
{
    /// <summary>
    /// Provides numeric constraint validation at serialization time
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public class NumericConstraintAttribute<T> : JsonConverterAttribute where T : struct, INumber<T>
    {

        T? _minValue = null, _maxValue = null;
        public NumericConstraintAttribute()
        {
        }

        /// <summary>
        /// Provides the minimum value
        /// </summary>
        public T MinValue { get { return _minValue.HasValue ? _minValue.Value : default(T); } set { _minValue = value; } }
        /// <summary>
        /// Provides the maximum allowed value
        /// </summary>
        public T MaxValue { get { return _maxValue.HasValue ? _maxValue.Value : default(T); } set { _maxValue = value; } }
        /// <summary>
        /// If true, then values greater than but not equal to the minimum value are allowed
        /// </summary>
        public bool MinValueExclusive { get; set; }
        /// <summary>
        /// If true, values less than, but not equal to the provided maximum are allowed
        /// </summary>
        public bool MaxValueExclusive { get; set; }

        public override JsonConverter? CreateConverter(Type typeToConvert)
        {
            return new NumericJsonConverter<T>(_minValue, _maxValue, MinValueExclusive, MaxValueExclusive);
        }
    }

    public class NumericJsonConverter<T> : JsonConverter<T> where T : struct, INumber<T>
    {
        string _rangeString;
        public NumericJsonConverter(T? minValue = null, T? maxValue = null, bool? minValueExclusive = false, bool? maxValueExclusive = false, JsonSerializerOptions? options = null)
        {
            MinValue = minValue;
            MaxValue = maxValue;
            MinValueExclusive = minValueExclusive.HasValue ? minValueExclusive.Value : false;
            MaxValueExclusive = maxValueExclusive.HasValue ? maxValueExclusive.Value : false;
            _rangeString = $"{(MinValue.HasValue ? (MinValueExclusive ? $"({MinValue}" : $"[{MinValue}") : $"[{typeof(T).Name}.Min")}, {(MaxValue.HasValue ? (MaxValueExclusive ? $"{MaxValue})" : $"{MaxValue}]") : $"{typeof(T).Name}.Max]")}";
            if (options != null)
            {
                InnerConverter = options.GetConverter(typeof(T)) as JsonConverter<T>;
            }
        }

        protected T? MinValue { get; }
        protected bool MinValueExclusive { get; }
        protected T? MaxValue { get; }

        protected bool MaxValueExclusive { get; }

        private JsonConverter<T>? InnerConverter { get; set; }

        private JsonConverter<T> GetInnerConverter(JsonSerializerOptions options)
        {
            if (InnerConverter == null)
            {
                InnerConverter = (JsonConverter<T>)options.GetConverter(typeof(T));
            }

            return InnerConverter;
        }
        public override T Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var inner = GetInnerConverter(options);
            T candidate = inner.Read(ref reader, typeToConvert, options);
            ValidateRange(candidate);
            return candidate;
        }

        public override void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options)
        {
            ValidateRange(value);
            GetInnerConverter(options).Write(writer, value, options);
        }

        protected virtual void ValidateRange(T value)
        {
            if ((MinValue.HasValue && (value < MinValue.Value || (value == MinValue.Value && MinValueExclusive)))
                || (MaxValue.HasValue && (value > MaxValue.Value || (value == MaxValue.Value && MaxValueExclusive))))
                throw new JsonException($"{value} is outside the allowed range of {_rangeString}");
        }
    }
}
```

\lib\StringArrayConstraintAttribute.cs:
```
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// <auto-generated />
#nullable enable

using System.Text.Json;
using System.Text.Json.Serialization;

namespace TypeSpec.Helpers.JsonConverters
{
    /// <summary>
    /// Constrains an array of strings
    /// </summary>
    public class StringArrayConstraintAttribute : ArrayConstraintAttribute<string>
    {
        int? _minItemLength = null, _maxItemLength = null;
        public StringArrayConstraintAttribute() : base()
        {
        }

        public int MinItemLength { get { return _minItemLength.HasValue ? _minItemLength.Value : 0; } set { _minItemLength = value; } }
        public int MaxItemLength { get { return _maxItemLength.HasValue ? _maxItemLength.Value : 0; } set { _maxItemLength = value; } }
        public string? Pattern { get; set; }

        override public JsonConverter<string[]> CreateConverter(Type typeToConvert)
        {
            var result = base.CreateConverter(typeToConvert) as ConstrainedArrayConverter<string>;
            result!.InnerConverterFactory = (c, o) => new StringJsonConverter(MinItemLength, MaxItemLength, Pattern, o);
            return result;
        }
    }
}
```

\lib\StringConstraintAttribute.cs:
```
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// <auto-generated />
#nullable enable

using System.Text.Json;
using System.Text.Json.Serialization;

namespace TypeSpec.Helpers.JsonConverters
{
    /// <summary>
    /// Provides constraints for a string values property
    /// </summary>
    public class StringConstraint : JsonConverterAttribute
    {
        int? _minLength = null, _maxLength = null;
        public StringConstraint()
        {
        }

        /// <summary>
        /// The minimum length of the string
        /// </summary>
        public int MinLength { get { return _minLength.HasValue ? _minLength.Value : 0; } set { _minLength = value; } }
        /// <summary>
        /// The maximum length of the string
        /// </summary>
        public int MaxLength { get { return _maxLength.HasValue ? _maxLength.Value : 0; } set { _maxLength = value; } }
        /// <summary>
        /// The pattern that the string must match
        /// </summary>
        public string? Pattern { get; set; }

        public override JsonConverter? CreateConverter(Type typeToConvert)
        {
            return new StringJsonConverter(_minLength, _maxLength, Pattern);
        }
    }

    public class StringJsonConverter : JsonConverter<string>
    {
        public StringJsonConverter(int? minLength, int? maxLength, string? pattern, JsonSerializerOptions? options = null)
        {
            MinLength = minLength;
            MaxLength = maxLength;
            Pattern = pattern;
            if (options != null)
            {
                InnerConverter = options.GetConverter(typeof(string)) as JsonConverter<string>;
            }
        }

        protected int? MinLength { get; }
        protected int? MaxLength { get; }
        protected string? Pattern { get; }

        private JsonConverter<string>? InnerConverter { get; set; }

        private JsonConverter<string> GetInnerConverter(JsonSerializerOptions options)
        {
            if (InnerConverter == null)
            {
                InnerConverter = (JsonConverter<string>)options.GetConverter(typeof(string));
            }

            return InnerConverter;
        }

        public override bool CanConvert(Type typeToConvert)
        {
            return base.CanConvert(typeToConvert);
        }

        public override string? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var innerConverter = GetInnerConverter(options);
            string? candidate = innerConverter.Read(ref reader, typeToConvert, options);
            if (MinLength.HasValue && (candidate == null || candidate.Length < MinLength.Value))
            {
                throw new JsonException($"String length less than minimum length {MinLength.Value}");
            }

            if (candidate != null)
            {
                if (MaxLength.HasValue && candidate.Length > MaxLength.Value)
                {
                    throw new JsonException($"String length greater than maximum length {MaxLength.Value}");
                }

                if (Pattern != null && !System.Text.RegularExpressions.Regex.IsMatch(candidate, Pattern))
                {
                    throw new JsonException($"String does not match pattern {Pattern}");
                }
            }

            return candidate;
        }

        public override void Write(Utf8JsonWriter writer, string value, JsonSerializerOptions options)
        {
            if (MinLength.HasValue && (value == null || value.Length < MinLength.Value))
            {
                throw new JsonException($"String length less than minimum length {MinLength.Value}");
            }

            if (value != null)
            {
                if (MaxLength.HasValue && value.Length > MaxLength.Value)
                {
                    throw new JsonException($"String length greater than maximum length {MaxLength.Value}");
                }

                if (Pattern != null && !System.Text.RegularExpressions.Regex.IsMatch(value, Pattern))
                {
                    throw new JsonException($"String does not match pattern {Pattern}");
                }

                GetInnerConverter(options).Write(writer, value, options);
            }
        }
    }
}
```

\lib\TimeSpanDurationConverter.cs:
```
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// <auto-generated />
#nullable enable

using System.Text.Json;
using System.Text.Json.Serialization;
using System.Xml;

namespace TypeSpec.Helpers.JsonConverters
{
    /// <summary>
    /// Converts between Json duration and .Net TimeSpan
    /// </summary>
    public class TimespanDurationConverter : JsonConverter<TimeSpan>
    {
        public override TimeSpan Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            if (typeToConvert != typeof(TimeSpan))
                throw new ArgumentException($"Cannot apply converter {this.GetType().FullName} to type {typeToConvert.FullName}");

            var value = reader.GetString();
            if (string.IsNullOrWhiteSpace(value)) return TimeSpan.MinValue;
            return XmlConvert.ToTimeSpan(value);
        }

        public override void Write(Utf8JsonWriter writer, TimeSpan value, JsonSerializerOptions options)
        {
            writer.WriteStringValue(XmlConvert.ToString(value));
        }
    }
}

```

\lib\UnixEpochDateTimeConverter.cs:
```
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// <auto-generated />
#nullable enable

using System.Text.Json;
using System.Text.Json.Serialization;

namespace TypeSpec.Helpers.JsonConverters
{
    /// <summary>
    /// Converts between an integer timestamp and a .Net DateTime
    /// </summary>
    public sealed class UnixEpochDateTimeConverter : JsonConverter<DateTime>
    {
        static readonly DateTime s_epoch = new DateTime(1970, 1, 1, 0, 0, 0);

        public override DateTime Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var formatted = reader.GetInt64()!;
            return s_epoch.AddMilliseconds(formatted);
        }

        public override void Write(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options)
        {
            long unixTime = Convert.ToInt64((value - s_epoch).TotalMilliseconds);
            writer.WriteNumberValue(unixTime);
        }
    }
}

```

\lib\UnixEpochDateTimeOffsetConverter.cs:
```
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// <auto-generated />
#nullable enable

using System.Text.Json;
using System.Text.Json.Serialization;

namespace TypeSpec.Helpers.JsonConverters
{
    /// <summary>
    /// Converts between a Unix TimeStamp and a .Net DateTimeOffset
    /// </summary>
    public sealed class UnixEpochDateTimeOffsetConverter : JsonConverter<DateTimeOffset>
    {
        static readonly DateTimeOffset s_epoch = new DateTimeOffset(1970, 1, 1, 0, 0, 0, TimeSpan.Zero);


        public override DateTimeOffset Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var formatted = reader.GetInt64()!;
            return s_epoch.AddMilliseconds(formatted);
        }

        public override void Write(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options)
        {
            long unixTime = Convert.ToInt64((value - s_epoch).TotalMilliseconds);
            writer.WriteNumberValue(unixTime);
        }
    }
}

```

\models\AudioUpload.cs:
```
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// <auto-generated />

using System;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace AudioTranslationService.Models.Service.Models
{

    public partial class AudioUpload
    {
        public string UploadId { get; set; }

        public string FileName { get; set; }

        public float FileSize { get; set; }

        public string UploadDate { get; set; }


    }
}

```

\models\ErrorResponse.cs:
```
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// <auto-generated />

using System;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace AudioTranslationService.Models.Service.Models
{

    public partial class ErrorResponse
    {
        public string ErrorCode { get; set; }

        public string ErrorMessage { get; set; }


    }
}

```

\models\InputValidation.cs:
```
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// <auto-generated />

using System;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace AudioTranslationService.Models.Service.Models
{

    public partial class InputValidation
    {
        public string[] Rules { get; set; }


    }
}

```

\models\InvalidFileError.cs:
```
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// <auto-generated />

using System;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace AudioTranslationService.Models.Service.Models
{

    public partial class InvalidFileError : ErrorResponse
    {
        public new string ErrorCode { get; } = "INVALID_FILE";

        public new string ErrorMessage { get; } = "The uploaded file is invalid.";


    }
}

```

\models\NotificationPreferences.cs:
```
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// <auto-generated />

using System;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace AudioTranslationService.Models.Service.Models
{

    public partial class NotificationPreferences
    {
        public string UserId { get; set; }

        public bool EmailNotifications { get; set; }


    }
}

```

\models\Payment.cs:
```
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// <auto-generated />

using System;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace AudioTranslationService.Models.Service.Models
{

    public partial class Payment
    {
        public string PaymentId { get; set; }

        public string UserId { get; set; }

        public float Amount { get; set; }

        public string[] LanguageOptions { get; set; }

        public string Service { get; set; }


    }
}

```

\models\PaymentFailureError.cs:
```
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// <auto-generated />

using System;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace AudioTranslationService.Models.Service.Models
{

    public partial class PaymentFailureError : ErrorResponse
    {
        public new string ErrorCode { get; } = "PAYMENT_FAILURE";

        public new string ErrorMessage { get; } = "Payment processing failed.";


    }
}

```

\models\RateLimiting.cs:
```
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// <auto-generated />

using System;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace AudioTranslationService.Models.Service.Models
{

    public partial class RateLimiting
    {
        public int Limit { get; set; }

        public string Window { get; set; }


    }
}

```

\models\SecureStorage.cs:
```
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// <auto-generated />

using System;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace AudioTranslationService.Models.Service.Models
{

    public partial class SecureStorage
    {
        public string Encryption { get; set; }


    }
}

```

\models\TranslationJob.cs:
```
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// <auto-generated />

using System;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace AudioTranslationService.Models.Service.Models
{

    public partial class TranslationJob
    {
        public string JobId { get; set; }

        public string UploadId { get; set; }

        public string Status { get; set; }

        public float Progress { get; set; }

        public string CreatedAt { get; set; }


    }
}

```

\models\User.cs:
```
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// <auto-generated />

using System;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace AudioTranslationService.Models.Service.Models
{

    public partial class User
    {
        public string UserId { get; set; }

        public string Name { get; set; }

        public string Email { get; set; }

        public string Password { get; set; }


    }
}

```

\operations\INotificationsOperations.cs:
```
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// <auto-generated />

using System;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Net;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using AudioTranslationService.Models.Service.Models;

namespace AudioTranslationService.Models.Service
{

    public interface INotificationsOperations
    {
        Task<string> ManageNotificationsAsync(NotificationPreferences notificationpreferences);

    }
}

```

\operations\IOperationsOperations.cs:
```
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// <auto-generated />

using System;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Net;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using AudioTranslationService.Models.Service.Models;

namespace AudioTranslationService.Models.Service
{

    public interface IOperationsOperations
    {
        Task<User> GetUserProfileAsync();
        Task<string> UpdateUserProfileAsync(User models);
        Task<AudioUpload> GetUploadDetailsAsync(string uploadId);
        Task<string> DeleteUploadAsync(string uploadId);
        Task ListJobsAsync();
        Task<string> CancelJobAsync(string jobId);

    }
}

```

\operations\IRoutesOperations.cs:
```
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// <auto-generated />

using System;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Net;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using AudioTranslationService.Models.Service.Models;

namespace AudioTranslationService.Models.Service
{

    public interface IRoutesOperations
    {
        Task<User> RegisterAsync(User user);
        Task<string> LoginAsync(User user);
        Task<Payment> ProcessPaymentAsync(Payment payment);
        Task<AudioUpload> UploadAudioAsync(AudioUpload audioupload);
        Task<TranslationJob> StartTranslationAsync(TranslationJob translationjob);
        Task<TranslationJob> CheckStatusAsync(string jobId);
        Task<byte[]> DownloadArtifactAsync(string jobId);

    }
}

```

